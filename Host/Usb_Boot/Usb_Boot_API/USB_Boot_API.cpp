// Generated by DriverWizard version DriverStudio 3.1.0 (Build 1722)
//
// This console application demonstrates how to open a handle
// to a device in your driver, and communicate with the driver
// using Read, Write, and DeviceIoControl calls, as appropriate.
//
// This test program attempts to open the device using the

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include "..\Usb_Boot_Driver\Usb_Boot_Interface.h" 
#include "..\Usb_Boot_Driver\Usb_Boot_Ioctl.h"	   
#include "Usb_Boot_defines.h"
#include "USB_Boot_API.h"
 
extern HANDLE OpenByInterface(GUID* pClassGuid, DWORD instance, PDWORD pError);

int JZ4740_USB_GET_CPU_INFO(HANDLE hDevice);
int JZ4740_USB_SET_DATA_ADDRESS(unsigned int addr,HANDLE	hDevice);
int JZ4740_USB_SET_DATA_LENGTH(unsigned int len,HANDLE hDevice);
int JZ4740_USB_FLUSH_CACHES(HANDLE hDevice);
int JZ4740_USB_PROG_START1(unsigned int addr,HANDLE hDevice);
int JZ4740_USB_PROG_START2(unsigned int addr,HANDLE hDevice);
int JZ4740_USB_NOR_OPS(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_NAND_OPS(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_SDRAM_OPS(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_CONFIGRATION(unsigned int ops,HANDLE hDevice);
int JZ4740_USB_GET_NUM(HANDLE	hDevice);

 HANDLE	hDevice = INVALID_HANDLE_VALUE;
 GUID ClassGuid = Jz4740_usbDevice_CLASS_GUID;

// Global data
#define N_IOCODES	10//6
char *IOnames[N_IOCODES+1] =
{
	"JZ4740_USB_IOCTL_GET_CPU_INFO",
	"JZ4740_USB_IOCTL_SET_DATA_ADDRESS",
	"JZ4740_USB_IOCTL_SET_DATA_LENGTH",
	"JZ4740_USB_IOCTL_FLUSH_CACHES",
	"JZ4740_USB_IOCTL_PROG_START1",
	"JZ4740_USB_IOCTL_PROG_START2",
	"JZ4740_USB_IOCTL_NOR_OPS",
	"JZ4740_USB_IOCTL_NAND_OPS",
	"JZ4740_USB_IOCTL_CONFIGRATION",
	"JZ4740_USB_IOCTL_GET_NUM",
	""
};

// IOCTL codes
//
int IOcodes[N_IOCODES+1] =
{
	JZ4740_USB_IOCTL_GET_CPU_INFO,
	JZ4740_USB_IOCTL_SET_DATA_ADDRESS,
	JZ4740_USB_IOCTL_SET_DATA_LENGTH,
	JZ4740_USB_IOCTL_FLUSH_CACHES,
	JZ4740_USB_IOCTL_PROG_START1,
	JZ4740_USB_IOCTL_PROG_START2,
	JZ4740_USB_IOCTL_NOR_OPS,
	JZ4740_USB_IOCTL_NAND_OPS,
	JZ4740_USB_IOCTL_CONFIGRATION,
	JZ4740_USB_IOCTL_GET_NUM,
	0
};

const char NAND_SECTION[][30]=
{
	"BUSWIDTH",			//The width of the NAND flash chip in bits (8|16|32)
	"ROWCYCLES",		//The row address cycles (2|3)
	"PAGESIZE",			//The page size of the NAND chip in bytes
	"PAGEPERBLOCK",		//The page number per block
	"FORCEERASE",
	"PAGENUMBER",
	"OOBSIZE"
};

const char IMAGE_TYPE[][30]=
{
	"with oob and ecc",
	"with oob and without oob",
	"without oob",
};

DWORD	Error;
short err;
char ret[8];
hand_t Hand,*hand_p;
ULONG nWritten,nRead;
extern unsigned char code_buf[MAX_TRANSFER_SIZE];
unsigned char check_buf[MAX_TRANSFER_SIZE];
int wait_delay = 0x7ffffff;

int Handle_Open(int obj)
{
	hDevice = OpenByInterface( &ClassGuid, obj, &Error);
	if (hDevice == INVALID_HANDLE_VALUE) return -1;
	else return 1;
}

int Handle_Close(void)
{
	if (hDevice != INVALID_HANDLE_VALUE)
	{
		// Close the handle to the driver
		if (!CloseHandle(hDevice))
		{
			//printf("ERROR: CloseHandle returns %0x.\n", GetLastError());
			return -1;
		}
	}
		hDevice = INVALID_HANDLE_VALUE;
	return 1;
}

int Error_Check(unsigned char *org,unsigned char * obj,unsigned int size)
{
	unsigned int i;
	//printf(" %d:%d ",org[0],obj[0]);
	for (i=0;i<size;i++)
	{
		//printf(" %d:%d ",org[i],obj[i]);
		if (org[i]!=obj[i]) 
		{
			printf("\n Check Error! %d",i);
			return 0;
		}
	}
	//printf("\n Check pass");
	return 1;
}

void Error_Handle(unsigned int err)
{
}


int Read_Load_CFG(char * fname)
{
	FILE *fp;
	char line[100];
	unsigned short i,j;
	unsigned long temp;
	if ((fp=fopen(fname,"rt"))==NULL)
	{
		printf("\n Can not open configration file!");
		return 0;
	}
	
	while(!strstr(line,"[FLASH]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
	}
	while(!strstr(line,"[NAND]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
		//printf("\n %s",line);
	}
	//Load [FLASH] section here
	//implement later

	while(!strstr(line,"[EEPROM]"))
	{
		if (feof(fp))
		{
			printf("\n USBBoot.cfg is bad!");
			return -1;
		}
		fgets(line,100,fp);
		for (i=0;i<strlen(line);i++)
			if (line[i]==';') line[i]='\0';
		//printf("\n %s",line);
		for (i=0;i<NAND_SECTION_NUM;i++)
			if (strstr(line,NAND_SECTION[i])) break;
		//printf("\n%d",i);
		switch (i)
		{
		case 0:		//BUSWIDTH
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_bw=temp;				//set the data!!
			//printf("\n BUSWIDTH: %d",temp);
			break;
		case 1:		//ROWCYCLES
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_rc=temp;				//set the data!!
			//printf("\n ROWCYCLES: %d",temp);
			break;
		case 2:		//PAGESIZE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_ps=temp;				//set the data!!
			//printf("\n PAGESIZE: %d",temp);
			break;
		case 3:		//PAGEPERBLOCK
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_ppb=temp;				//set the data!!
			//printf("\n PAGEPERBLOCK: %d",temp);
			break;
		case 4:		//FORCEERASE
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_force_erase=temp;				//set the data!!
			//printf("\n FORCEERASE: %d",temp);
			break;
        case 5:		//PAGENUMBER
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_pn=temp;				//set the data!!
			//printf("\n PAGENUMBER: %d",temp);
			break;
		case 6:
			j=0;
			temp=0;
			while(j<strlen(line) && line[j]!=' ' && line[j]!=9) 
				j++;
			if (j==strlen(line)) continue;
			while (j<strlen(line) &&(line[j]==' '||line[j]==9))
				j++; 
			if (j==strlen(line)) continue;
			while (j<strlen(line) && line[j]!=' ' && line[j]!=9)
			temp=temp*10+(line[j++]-0x30);
			Hand.nand_os=temp;				//set the data!!
			//printf("\n OOBSIZE: %d",temp);
			break;
		default:;
		}
	}
	//Load [NAND] section here
return 1;
}
 
void Init_Hand_Def(void)
{
	Hand.devtype=0;   /* device types: nor/nand/eeprom etc. */
	Hand.optype=0;    /* operation types: read/write/erase etc. */
	Hand.address=0;   /* operation address value */
	Hand.count=0;     /* operation count value */
	Hand.finished=0;           /* operation finished flag */
	Hand.error=0;              /* operation error flag */
	Hand.done_count=0; /* count value that has been done */

	/* host data buffer */
	Hand.database=0;  /* data buffer base */
	Hand.datasize=0;  /* data buffer size in bytes */

	/* nor flash fields */
	Hand.chiptype=0;    /* chip type */
	Hand.chipwidth=0;   /* chip width 8/16/32 */
	Hand.buswidth=0;    /* data bus width 8/16/32 */
	Hand.baseaddr=0;    /* flash base address */
	Hand.chipsize=0;    /* chip size in bytes */
	Hand.sectorsize=0;  /* sector size in bytes */
	Hand.setup_addr1=0; /* flash setup address 1 */
	Hand.setup_addr2=0; /* flash setup address 2 */

	/* nand flash info */
	Hand.nand_start=0;				//important !!!!
	Hand.nand_bw=8;
	Hand.nand_rc=3;
	Hand.nand_ps=2048;
	Hand.nand_ppb=64;
	Hand.nand_force_erase=0;
	Hand.nand_ids=0;  /* vendor_id & device_id */

	/* sdram info */
	Hand.sdram_bw=0;
	Hand.sdram_banks=0;
	Hand.sdram_rows=0;
	Hand.sdram_cols=0;
	Hand.sdram_casl=0;

	Hand.sdram_status_enable=0;
	Hand.sdram_address=0;
	Hand.sdram_true_value=0;
	Hand.sdram_bad_value=0;
}

int Init_CFG(char *fname)
{
	ULONG nWritten,nRead;
	//char ret[8];
	if (API_IsBoot()!=1)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	if (!Read_Load_CFG(fname))
		return -1;
	WriteFile(hDevice, &Hand, sizeof(Hand), &nWritten, NULL);	//Send Hand_t data structure
	JZ4740_USB_CONFIGRATION(DS_hand,hDevice);			//Send VR request
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	return 1;
}


int Handle_Stage1(char *fw,char *usbboot)
{
	FILE *fp;
	unsigned int flen;
	ULONG nWriten;

	if ((fp=fopen(fw,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",fw);
		return -1;
	}
	//fread(code_buf,1,flen,fp);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	if (flen>16384)
	{
		printf("\n Cache file is too large!");
		return -1;
	}
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	JZ4740_USB_GET_CPU_INFO(hDevice);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80000000,hDevice)!=1) return -1;
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	//WriteFile(hDevice, fw1, sizeof(fw1), &nWriten, NULL);			//write code_1
	if (JZ4740_USB_PROG_START1(0x80000000,hDevice)!=1) return -1;	//execute code_1 ,init SDRAM
	wait_delay = 0x7ffffff;
	while(wait_delay--);											//wait for return
	JZ4740_USB_GET_CPU_INFO(hDevice);
	fclose(fp);

	if ((fp=fopen(usbboot,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",usbboot);
		return -1;
	}
	//fread(code_buf,1,flen,fp);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x82600000,hDevice)!=1) return -1;	//it is ucos
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	JZ4740_USB_GET_CPU_INFO(hDevice);
	JZ4740_USB_FLUSH_CACHES(hDevice);
	if (JZ4740_USB_PROG_START2(0x82600000,hDevice)!=1) return -1;				//execute code_2 ,now we can do usbboot!
	fclose(fp);
	return 1;
} 

int Handle_Stage1_new(char *fw,char *uboot,char *uImage)
{
	FILE *fp;
	unsigned int flen;
	ULONG nWriten;

	if ((fp=fopen(fw,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",fw);
		return 0;
	}
	//fread(code_buf,1,flen,fp);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	if (flen>16384)
	{
		printf("\n Cache file is too large!");
		return 0;
	}
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	JZ4740_USB_GET_CPU_INFO(hDevice);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80000000,hDevice)!=1) return -1;
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	//WriteFile(hDevice, fw1, sizeof(fw1), &nWriten, NULL);			//write code_1
	if (JZ4740_USB_PROG_START1(0x80000000,hDevice)!=1) return -1;	//execute code_1 ,init SDRAM
	wait_delay = 0x7ffffff;
	while(wait_delay--);											//wait for return
	JZ4740_USB_GET_CPU_INFO(hDevice);
	fclose(fp);

	if ((fp=fopen(uboot,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",uboot);
		return 0;
	}
	//fread(code_buf,1,flen,fp);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	fseek(fp,0x20000,SEEK_SET);
	fread(code_buf,1,0x20000,fp);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80100000,hDevice)!=1) return -1;	//it is ucos
	WriteFile(hDevice, code_buf, 0x20000, &nWriten, NULL);			//write code_1
	JZ4740_USB_GET_CPU_INFO(hDevice);
	JZ4740_USB_FLUSH_CACHES(hDevice);
	//if (JZ4740_USB_PROG_START2(0x80100000,hDevice)!=1) return -1;				//execute code_2 ,now we can do usbboot!
	fclose(fp);

	if ((fp=fopen(uImage,"rb"))==NULL)
	{
		printf("\n Can not open file :%s",uImage);
		return 0;
	}
	//fread(code_buf,1,flen,fp);
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	fseek(fp,0,SEEK_SET);
	fread(code_buf,1,flen,fp);
	if (JZ4740_USB_SET_DATA_ADDRESS(0x80600000,hDevice)!=1) return -1;	//it is ucos
	WriteFile(hDevice, code_buf, flen, &nWriten, NULL);			//write code_1
	JZ4740_USB_GET_CPU_INFO(hDevice);
	JZ4740_USB_FLUSH_CACHES(hDevice);
	if (JZ4740_USB_PROG_START2(0x80100000,hDevice)!=1) return -1;				//execute code_2 ,now we can do usbboot!
	fclose(fp);
	return 1;
}


int API_Init()
{
	Init_Hand_Def();
	Read_Load_CFG("USBBoot.cfg");
	return 1;
}

int API_IsBoot(void)
{
	return JZ4740_USB_GET_CPU_INFO(hDevice);
}

int API_Get_Dev_Num()		//：获取当前已经连接的设备个数
{
	int i,j=0;
	for (i=0;i<MAX_DEV_NUM;i++)
		if ((hDevice=OpenByInterface(&ClassGuid, i, &Error))!=INVALID_HANDLE_VALUE)
		{
			j++;
			Handle_Close();
		}
	/*hDevice = OpenByInterface(&ClassGuid, 0, &Error);
	if (hDevice == INVALID_HANDLE_VALUE) return 0;
	else 
	{
		i=JZ4740_USB_GET_NUM(hDevice);
		return i;
	}
	return 1;*/
	return j;
}

/*int API_Select(int obj)		//：选中编号为obj的设备为操作对象
{
	if (obj>=MAX_DEV_NUM) return -1;
	dev_data[obj].op = 1;
	return 1;
}

int API_UnSelect(int obj)		//：取消对编号为obj的对象的选择
{
	if (obj>=MAX_DEV_NUM) return -1;
	dev_data[obj].op = 0;
	return 1;
}*/

//操作类API:
int API_Boot(int obj)				//：对选中的设备进行Boot操作
{
	int retry;

		printf("\n Booting No.%d device......",obj);
		if (Handle_Open(obj)==-1)
		{
			printf(" Boot fail!");
			printf("\n Can not connect device!");
			return -1;
		}
		if (API_IsBoot()==1)
		{
			printf("Booted!");
			return -1;
		}
		else printf(" UnBooted!");

		if (Handle_Stage1("fw.bin","usb_boot.bin")==-1)
//		if (Handle_Stage1("fw_16.bin","zImage")==-1)
//		if (Handle_Stage1("fw_16.bin","fw_15.bin")==-1)
		{
			printf("......Boot fail!");
		}		
		else printf("......Boot success!");
		Handle_Close();
		for (retry=0;retry<5;retry++)
		{
			wait_delay = 0xfffffff;
			while(wait_delay--);											//wait for return
			wait_delay = 0xfffffff;
			while(wait_delay--);											//wait for return

			if (Handle_Open(obj)==-1) printf("\n Retrying reconnect with device %d",retry);
			else 
			{
				break;
			}
		}
		if (retry >=5) 
		{
			printf("\n Can not connect device!");
			printf("\n Device have not init!");
			return -1;
		}
 
		printf("\n Initing No.%d device......",obj);
		Init_Hand_Def();
		if (Init_CFG("USBBoot.cfg")==1)
			printf("Init Configration success!");
		else printf("Init Configration fail!");
		Handle_Close();
	return 1;
}

int API_Fconfig(int obj,char *fname)	//：用fname指定的配置文件对设备进行配置
{
		printf("\n Configing No.%d device....",obj);
		if (Handle_Open(obj)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}
		if (!Read_Load_CFG(fname))
		{
			printf(" Init CFG fail!");
			return -1;
		}

		WriteFile(hDevice, &Hand, sizeof(Hand), &nWritten, NULL);	//Send Hand_t data structure
		JZ4740_USB_CONFIGRATION(DS_hand,hDevice);			//Send VR request
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Init Configration success!");
		Handle_Close();
	return 1;
}

int API_Go(int obj,unsigned int addr)			//：从RAM中的addr地址开始运行程序
{
		printf("\n Executing No.%d device....",obj);
		if (Handle_Open(obj)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}
		JZ4740_USB_PROG_START2(addr,hDevice);
		Handle_Close();
	
	return 1;
}

int API_Nand_Program_File(NAND_IN *nand_in,NAND_OUT *nand_out,char *fname)
{
	int i,flen,m,j,k;
	unsigned int start_page=0,page_num,code_len,offset;
	FILE *fp;

	NAND_IN n_in;
	NAND_OUT n_out;

	nand_out->status = (unsigned char *)malloc(nand_in->max_chip * sizeof(unsigned char));
	for (i=0;i<nand_in->max_chip;i++)
		(nand_out->status)[i] = 0;								//set all status to fail

		fp=fopen(fname,"rb");
		if (fp==NULL)
		{
			printf("\n Can not open file !");
			return 0;
		}
		printf("\n Programing No.%d device...",nand_in->dev);
		fseek(fp,0,SEEK_END);
		flen=ftell(fp);
		n_in.start = nand_in->start /Hand.nand_ppb;
		if (nand_in->option == NO_OOB)
			n_in.length = (flen /Hand.nand_ps) /Hand.nand_ppb +1;
		else 
			n_in.length = (flen /(Hand.nand_ps + Hand.nand_os)) /Hand.nand_ppb +1;
		n_in.cs_map = nand_in->cs_map;
		n_in.dev = nand_in->dev;
		n_in.max_chip = nand_in->max_chip;
		if (API_Nand_Erase(&n_in)!=1) return -1;

		m = flen / MAX_TRANSFER_SIZE;
		j = flen % MAX_TRANSFER_SIZE;
		fseek(fp,0,SEEK_SET);		//file point return to begin
		offset = 0;
		printf("\n Total size to send in byte is :%d",flen);
		printf("\n Image type : %s",IMAGE_TYPE[nand_in->option]);
		printf("\n It will cause %d times buffer transfer.",m+1);
		for (i=0;i<nand_in->max_chip;i++)
			(nand_out->status)[i] = 1;								//set all status to fail

		for (k=0;k<m;k++)
		{
			if (nand_in->option == NO_OOB)
			{
				page_num = MAX_TRANSFER_SIZE / Hand.nand_ps;
			}else
			{
				page_num = MAX_TRANSFER_SIZE / (Hand.nand_ps + 64);
			}
			code_len = MAX_TRANSFER_SIZE;
//			memset(code_buf,0,code_len);		//set all to null
			fread(code_buf,1,code_len,fp);			//read code from file to buffer

			printf("\n No.%d Programming......",k+1);
			nand_in->length = code_len;               //code length,not page number!
			nand_in->buf = code_buf;
			API_Nand_Program_Check(nand_in,&n_out);
			//printf(" Finish!");
			for (i=0;i<nand_in->max_chip;i++)
			{
				(nand_out->status)[i] = (nand_out->status)[i] * (n_out.status)[i];
			}

			//offset += code_len - 1;
			offset += code_len ;
			//start_page += page_num;
			nand_in->start += page_num;
			fseek(fp,offset,SEEK_SET);
		}

		if (j)
		{
//			memset(code_buf,0,code_len);				//set all to null
			fread(code_buf,1,j,fp);						//read code from file to buffer
			nand_in->length = j;
			nand_in->buf = code_buf;
			printf("\n No.%d Programming......",k+1);
			API_Nand_Program_Check(nand_in,&n_out);
			//printf(" Finish!");
			for (i=0;i<nand_in->max_chip;i++)
			{
				(nand_out->status)[i] = (nand_out->status)[i] * (n_out.status)[i];
 			}
		}
	
		fclose(fp);
	//}
	return 1;
}

int API_Nand_Read(NAND_IN *nand_in,char *fname)
{
	int i,j;
	unsigned int start_addr = nand_in->start,length = nand_in->length,page_num;
	unsigned char csn;
	unsigned short temp;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (start_addr > NAND_MAX_PAGE_NUM || length > NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot()!=1)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		//memset(nand_in->buf,0,page_num * Hand.nand_ps);
		printf("\n Reading from No.%d device No.%d flash....",nand_in->dev,csn);

		page_num = length / Hand.nand_ps +1;
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + NAND_READ;
		//printf("\n temp %x",temp);
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, page_num * Hand.nand_ps, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);

		for (j=0;j<length;j++) 
		{
			if (j % 16==0) printf("\n 0x%08x :",j);
			printf("%02x ",(nand_in->buf)[j]);
		}
		printf("\n Operation status: Success!");
		Handle_Close();

	return 1;
}

int API_Nand_Readoob(NAND_IN *nand_in,char *fname)
{
	int i,j;
	unsigned char csn;
	unsigned int start_addr = nand_in->start ,length = nand_in->length,page_num;
	ULONG	nRead;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (start_addr > NAND_MAX_PAGE_NUM || length> NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot()!=1)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		//memset(nand_in->buf,0,(length/Hand.nand_ps+1) * Hand.nand_ps);
		printf("\n Reading OOB from No.%d device No.%d flash....",nand_in->dev,csn);

		page_num = length/Hand.nand_ps+1;
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		unsigned short temp = ((csn<<4) & 0xff0) + NAND_READ_OOB;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, page_num * Hand.nand_ps, &nRead, NULL);

		for (j=0;j<length;j++) 
		{
			if (j % 16==0) printf("\n 0x%08x :",j);
			printf("%02x ",(nand_in->buf)[j]);
		}

		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Operation status: Success!");
		Handle_Close();
	
	return 1;
}

int API_Nand_Readraw(NAND_IN *nand_in,char *fname)
{
	int i,j;
	unsigned int start_addr = nand_in->start ,length = nand_in->length ,page_num;
	unsigned char csn;
	unsigned short temp;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (start_addr > NAND_MAX_PAGE_NUM || length> NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot()!=1)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		//memset(nand_in->buf,0,(length/Hand.nand_ps+1) * Hand.nand_ps);
		printf("\n Reading RAW from No.%d device No.%d flash....",nand_in->dev,csn);
		page_num = length/Hand.nand_ps +1;

		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + NAND_READ_RAW;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, page_num * Hand.nand_ps, &nRead, NULL);

		for (j=0;j<length;j++) 
		{
			if (j % 16==0) printf("\n 0x%08x :",j);
			printf("%02x ",(nand_in->buf)[j]);
		}

		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Operation status: Success!");
		Handle_Close();
	
	return 1;
}

int API_Nand_Erase(NAND_IN *nand_in)
{
	unsigned int start_blk,blk_num;
	int i;

	start_blk = nand_in->start;
	blk_num = nand_in->length;
		if (start_blk > (unsigned int)NAND_MAX_BLK_NUM) 
		{
			printf("\n Start block number overflow!");
			return -1;
		}
		if (blk_num > (unsigned int)NAND_MAX_BLK_NUM)
		{
			printf("\n Length block number overflow!");
			return -1;
		}
	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot()!=1)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}

	for (i=0;i<nand_in->max_chip;i++)
	{
		if ((nand_in->cs_map)[i]==0) continue;
		printf("\n Erasing No.%d device No.%d flash......",nand_in->dev,i);

		JZ4740_USB_SET_DATA_ADDRESS(start_blk,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(blk_num,hDevice);
		unsigned short temp = ((i<<4) & 0xff0) + NAND_ERASE;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf(" Finish!");
	}
	Handle_Close();
	printf("\n Operation status: Success!");
	return 1;
}

int API_Nand_Query(NAND_IN * nand_in)
{
	int i;
	unsigned char csn;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}
		if (API_IsBoot()!=1)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;
		printf("\n Querying No.%d device No.%d flash......",nand_in->dev,csn);
		unsigned short temp = ((csn<<4) & 0xff0) + NAND_QUERY;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, ret, 4, &nRead, NULL);
		printf("\n Nand flash Vendor ID :0x%x ",(unsigned char)ret[0]);
		printf("\n Nand flash Chip ID   :0x%x ",(unsigned char)ret[2]);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		printf("\n Operation status: Success!");
		Handle_Close();

	return 1;
}


int API_Nand_Program_Check(NAND_IN *nand_in,NAND_OUT *nand_out)
{
	unsigned int i,page_num;
	unsigned short temp;

	if (nand_in->length>MAX_TRANSFER_SIZE)
	{
		printf("\n Buffer size too long!");
		return -1;
	}
	nand_out->status = (unsigned char *)malloc(nand_in->max_chip * sizeof(unsigned char));

	for (i=0;i<nand_in->max_chip;i++)
		(nand_out->status)[i] = 0;								//set all status to fail

	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot()!=1)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	WriteFile(hDevice, nand_in->buf, nand_in->length , &nWritten, NULL);
	//WriteFile(hDevice, nand_in->buf, nand_in->length * Hand.nand_ps, &nWritten, NULL);			//Send data to be program
																				//Only send once!
	for (i=0;i<nand_in->max_chip;i++)
	{
		if ((nand_in->cs_map)[i]==0) continue;

			//page_num = nand_in->length / Hand.nand_ps +1;
			if (nand_in->option == NO_OOB) 
			{
				page_num = nand_in->length / Hand.nand_ps;
				if ((nand_in->length%Hand.nand_ps) !=0) page_num++;
				//temp = ((i<<4) & 0xff0) + NAND_PROGRAM;
			}
			else 
			{
				page_num = nand_in->length / (Hand.nand_ps + Hand.nand_os);
				if ((nand_in->length% (Hand.nand_ps + Hand.nand_os)) !=0) page_num++;
				//temp = ((i<<4) & 0xff0) + NAND_PROGRAM_OOB;
			}

			temp = ((nand_in->option<<12) & 0xf000)  + ((i<<4) & 0xff0) + NAND_PROGRAM;	
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			JZ4740_USB_NAND_OPS(temp,hDevice);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			printf(" Finish! ");
		switch (nand_in->option)
		{
		case OOB_ECC:
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);					//Read back to check!
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			temp = ((OOB_ECC<<12) & 0xf000) +((i<<4) & 0xff0) + NAND_READ_RAW;
			JZ4740_USB_NAND_OPS(temp,hDevice);
			printf("Checking ......");			
			ReadFile(hDevice, check_buf, page_num * (Hand.nand_ps + Hand.nand_os), &nRead, NULL);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			break;
		case OOB_NO_ECC:			//do not support data verify
			printf(" No check support!");
			//ReadFile(hDevice, ret, 8, &nRead, NULL);
			(nand_out->status)[i] = 1;
			continue;
		case NO_OOB:
			JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);					//Read back to check!
			JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
			temp = ((NO_OOB<<12) & 0xf000) +((i<<4) & 0xff0) + NAND_READ;
			JZ4740_USB_NAND_OPS(temp,hDevice);
			printf("Checking ......");
			ReadFile(hDevice, check_buf, page_num * Hand.nand_ps , &nRead, NULL);
			ReadFile(hDevice, ret, 8, &nRead, NULL);
			break;
		default:;
		}

			if (nand_in->Check(nand_in->buf,check_buf,nand_in->length)) 
			{
				(nand_out->status)[i] = 1;
				printf(" pass!");
			}
			else 
			{
				(nand_out->status)[i] = 0;
				printf(" fail!");
			}
	}
	Handle_Close();
	return 1;
}

int API_Read_Nand_To_Ram(NAND_IN *nand_in,unsigned int ram_addr)
{
	unsigned int i,temp;
	unsigned char csn;

		if (Handle_Open(nand_in->dev)==-1)
		{
			printf("\n Can not connect device!");
			return -1;
		}

		if (nand_in->start > NAND_MAX_PAGE_NUM || nand_in->length > NAND_MAX_PAGE_NUM )
		{
			printf("\n Page number overflow!");
			return -1;
		}
		if (API_IsBoot()!=1)
		{
			printf("\n Device unboot! Boot it first!");
			return -1;
		}
		for (i=0;i<nand_in->max_chip;i++) 
			if ((nand_in->cs_map)[i]!=0) break;
		if (i>=nand_in->max_chip) return 1;
		csn = i;

	printf("\n Reading from flash to ram of No.%d device No.%d flash....",nand_in->dev,csn);
	JZ4740_USB_PROG_START1(ram_addr,hDevice);
	JZ4740_USB_SET_DATA_ADDRESS(nand_in->start,hDevice);
	JZ4740_USB_SET_DATA_LENGTH(nand_in->length,hDevice);
	temp = ((NO_OOB<<12) & 0xf000) + ((csn<<4) & 0xff0) + NAND_READ_TO_RAM;
	JZ4740_USB_NAND_OPS(temp,hDevice);
	ReadFile(hDevice, ret, 8, &nRead, NULL);
	Handle_Close();

	return 1;
}

int API_Nand_Make(NAND_IN * nand_in,char *fname)
{
	int flen,m,j,k;
	FILE *fp;
	unsigned short temp;
	unsigned int start_addr,page_num,offset;
	if (Handle_Open(nand_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot()!=1)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	fp=fopen(fname,"w+b");
	if (fp==NULL)
	{
		printf("\n Can not open file !");
		return 0;
	}
	fseek(fp,0,SEEK_SET);		//file point return to begin
	flen = nand_in->length * (Hand.nand_ps + Hand.nand_os);
	m = flen / MAX_TRANSFER_SIZE;
	j = flen % MAX_TRANSFER_SIZE;
	start_addr = nand_in->start;
	offset = 0;
	for (k=0;k<m;k++)
	{
		page_num = MAX_TRANSFER_SIZE / (Hand.nand_ps + Hand.nand_os);
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((OOB_ECC<<12) & 0xf000) + (( 0 <<4) & 0xff0) + NAND_READ_RAW;
		//printf("\n temp %x",temp);
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, MAX_TRANSFER_SIZE, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		fwrite(nand_in->buf, 1 ,MAX_TRANSFER_SIZE,fp);
		start_addr += page_num;
		offset += MAX_TRANSFER_SIZE ;
		fseek(fp,offset,SEEK_SET);
	}

	if (j)
	{
		page_num = j/ (Hand.nand_ps + Hand.nand_os);
		JZ4740_USB_SET_DATA_ADDRESS(start_addr,hDevice);
		JZ4740_USB_SET_DATA_LENGTH(page_num,hDevice);
		temp = ((OOB_ECC<<12) & 0xf000) + (( 0 <<4) & 0xff0) + NAND_READ;
		JZ4740_USB_NAND_OPS(temp,hDevice);
		ReadFile(hDevice, nand_in->buf, j, &nRead, NULL);
		ReadFile(hDevice, ret, 8, &nRead, NULL);
		fwrite(nand_in->buf, 1 ,j,fp);
	}

	fclose(fp);
	Handle_Close();
	return 1;
}

int API_Sdram_Load(SDRAM_IN *sdram_in)
{

	if (Handle_Open(sdram_in->dev)==-1)
	{
		printf("\n Can not connect device!");
		return -1;
	}
	if (API_IsBoot()!=1)
	{
		printf("\n Device unboot! Boot it first!");
		return -1;
	}
	if (sdram_in->length > MAX_TRANSFER_SIZE)
	{
		printf("\n Image length too long!");
		return -1;
	}

	WriteFile(hDevice, sdram_in->buf, sdram_in->length , &nWritten, NULL);
	//JZ4740_USB_PROG_START1(sdram_in->object,hDevice);
	JZ4740_USB_SET_DATA_ADDRESS(sdram_in->start,hDevice);
	JZ4740_USB_SET_DATA_LENGTH(sdram_in->length,hDevice);
	//temp = ((OOB_ECC<<12) & 0xf000) + (( 0 <<4) & 0xff0) + NAND_READ;
	JZ4740_USB_SDRAM_OPS(SDRAM_LOAD,hDevice);

	Handle_Close();
	return 1;
}

int API_Sdram_Load_File(SDRAM_IN * sdram_in,char *fname)
{
	unsigned int flen,m,j,offset,k;
	FILE *fp;

	fp=fopen(fname,"rb");
	if (fp==NULL)
	{
		printf("\n Can not open file !");
		return -1;
	}
	fseek(fp,0,SEEK_END);
	flen=ftell(fp);
	
	m = flen / MAX_TRANSFER_SIZE;
	j = flen % MAX_TRANSFER_SIZE;
	fseek(fp,0,SEEK_SET);		//file point return to begin
	offset = 0;
	printf("\n Loading data to SDRAM......");
	printf("\n Total size to send in byte is :%d",flen);
	
	for (k=0;k<m;k++)
	{
		fread(sdram_in->buf,1,MAX_TRANSFER_SIZE,fp);			//read code from file to buffer
		sdram_in->length = MAX_TRANSFER_SIZE;
		API_Sdram_Load(sdram_in);
		//sdram_in->buf += MAX_TRANSFER_SIZE;
		//sdram_in->object += MAX_TRANSFER_SIZE;
		sdram_in->start += MAX_TRANSFER_SIZE;
		offset += MAX_TRANSFER_SIZE;
		fseek(fp,offset,SEEK_SET);
	}

	if (j)
	{
		if (j % 4 !=0) j += 4-(j%4);
		fread(sdram_in->buf,1,j,fp);
		sdram_in->length = j;
		API_Sdram_Load(sdram_in);
	}

	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_GET_CPU_INFO
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_GET_CPU_INFO(HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//Handle_connect();
	// Call device IO Control interface (JZ4740_USB_IOCTL_GET_CPU_INFO) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_GET_CPU_INFO,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	bufOutput[8] = '\0';
	//printf("\n CPU INFO = %s", bufOutput);
	if (!strcmp(bufOutput,"BOOTED!!")) return 1;
	else return -1;
	//return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_SET_DATA_ADDRESS
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_SET_DATA_ADDRESS(unsigned int addr,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput
	/*if (hDevice == INVALID_HANDLE_VALUE) 
	{
			hDevice = OpenByInterface( &ClassGuid, 0, &Error);
			if (hDevice == INVALID_HANDLE_VALUE) 
			{
				printf("\n Can not open device!");
				printf("\n Operation can not carry out until USB connect is ok!");
				return -1;
			}
	}*/
	//if (Handle_connect()!=1) return -1;
	//printf("Set ADDR 0x%x\n", addr);
	*(unsigned int *)bufInput = addr;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_SET_DATA_ADDRESS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_SET_DATA_LENGTH
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_SET_DATA_LENGTH(unsigned int len,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//if (Handle_connect()!=1) return -1;
	//printf("Set LEN %d\n", len);
	*(unsigned int *)bufInput = len;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_LENGTH) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_SET_DATA_LENGTH,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_FLUSH_CACHES
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_FLUSH_CACHES(HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("\n FLUSH_CACHES");
	//Handle_connect();
	// Call device IO Control interface (JZ4740_USB_IOCTL_FLUSH_CACHES) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_FLUSH_CACHES,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_PROG_START1
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_PROG_START1(unsigned int addr,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("PROG_START1\n");
	*(unsigned int *)bufInput = addr;
	// Call device IO Control interface (JZ4740_USB_IOCTL_PROG_START1) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_PROG_START1,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}

////////////////////////////////////////////////////////////////////////
// JZ4740_USB_IOCTL_PROG_START2
//
//		Test one Io Control Code
//
// TODO:
//		Pass appropriate arguments to your device and check
//		the return value
//
int JZ4740_USB_PROG_START2(unsigned int addr,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("PROG_START2\n");
	*(unsigned int *)bufInput = addr;

	// Call device IO Control interface (JZ4740_USB_IOCTL_PROG_START2) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_PROG_START2,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}


int JZ4740_USB_NOR_OPS(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_NOR_OPS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1;
}


int JZ4740_USB_NAND_OPS(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("Set NAND_OPS 0x%x\n", ops);
	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_NAND_OPS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	//bufOutput[9] = '\0';
	return 1;
	//(bufOutput[6]<<8) + bufOutput[7];
}


int JZ4740_USB_CONFIGRATION(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("Configration 0x%x\n", ops);
	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_CONFIGRATION,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return 1; 
		//(bufOutput[6]<<8) + bufOutput[7];
}

int JZ4740_USB_GET_NUM(HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//Handle_connect();
	// Call device IO Control interface (JZ4740_USB_IOCTL_GET_CPU_INFO) in driver
	//printf("Issuing Ioctl to device - GET_NUM");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_GET_NUM,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	return bufOutput[0];
	//printf("\n CPU INFO = %s", bufOutput);
	//return 1;
}

int JZ4740_USB_SDRAM_OPS(unsigned int ops,HANDLE	hDevice)
{
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	CHAR	bufInput[IOCTL_INBUF_SIZE];		// Input to device
	CHAR	bufOutput[IOCTL_OUTBUF_SIZE];	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	//printf("Set NAND_OPS 0x%x\n", ops);
	*(unsigned int *)bufInput = ops;

	// Call device IO Control interface (JZ4740_USB_IOCTL_SET_DATA_ADDRESS) in driver
	//printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 JZ4740_USB_IOCTL_SDRAM_OPS,
						 bufInput,
						 IOCTL_INBUF_SIZE,
						 bufOutput,
						 IOCTL_OUTBUF_SIZE,
						 &nOutput,
						 NULL)
	   )
	{
		printf("\n ERROR: DeviceIoControl returns %0x.", GetLastError());
		//Exit(1);
		return -1;
	}
	//bufOutput[9] = '\0';
	return 1;
	//(bufOutput[6]<<8) + bufOutput[7];
}
